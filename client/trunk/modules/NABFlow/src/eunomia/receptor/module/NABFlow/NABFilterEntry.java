/*
 * FilterEntry.java
 *
 * Created on July 31, 2005, 2:50 PM
 */

package eunomia.receptor.module.NABFlow;

import com.vivic.eunomia.filter.FilterEntry;
import com.vivic.eunomia.module.flow.Flow;
import eunomia.messages.FilterEntryMessage;
import eunomia.messages.Message;
import eunomia.receptor.module.NABFlow.messages.NABFlowSpecificMessage;

/**
 * The class that defines the specific parts of the filter entry for this module.
 * There is an option to override generic features, however that depends on the
 * module writer.
 * @author Mikhail Sosonkin
 */
public class NABFilterEntry extends FilterEntry {
    /**
     * This is really the only thing that this filter entry does specific, it keeps
     * track of what types should be filtered out.
     */
    private boolean[] allowType;
    
    private StringBuilder summary;
    
    /**
     * Created an entry with default values.
     */
    public NABFilterEntry(){
        this(null);
    }
    
    /**
     * 
     * @param fem The message with all the info, will be sent in by the middleware
     */
    public NABFilterEntry(FilterEntryMessage fem){
        super(fem);
        
        summary = new StringBuilder();
        
        // User experience shows that generally they want all type to be allowed
        // on some specialized cases the types can be excluded.
        allowType = new boolean[NABFlow.NUM_TYPES];
        for (int i = 0; i < allowType.length; i++) {
            allowType[i] = true;
        }
        
        if(fem != null){
            // if there is not specific information then set the default
            // to allow all types through.
            processSpecific(fem.getSpecific());
        }
    }

    public boolean[] getAllowType() {
        return allowType;
    }
    
    /**
     * Called by the constructor to process the message and set the allowed types.
     * @param msg The message that is generated by the <I>getSpecific()</I> method.
     */
    private void processSpecific(Message msg){
        if(msg != null && msg instanceof NABFlowSpecificMessage){
            boolean[] a = ((NABFlowSpecificMessage)msg).getAllow();
            
            // The message contains a single boolean array.
            for (int i = 0; i < a.length; i++) {
                allowType[i] = a[i];
            }
        }
    }
    
    /**
     * 
     * @param i Type number
     * @return the allow value
     */
    public boolean isAllowed(int i){
        return allowType[i];
    }
    
    /**
     * 
     * @param i The type number
     * @param v new allow value
     */
    public void setAllowed(int i, boolean v){
        allowType[i] = v;
    }
        
    /**
     * Checks if the flow is matches this entry, in this case the check is to return
     * the allow value for flow's type.
     * @param flow Flow to check
     * @return flag indicating whether or not the flow is allowed based on the type.
     */
    public boolean inRangeFlow(Flow flow) {
        if(flow instanceof NABFlow){
            // This entry can only check the NABFlow flows. Everything else is allowed
            // to pass. However, again, the actual enforcement is done by the Flow
            // Processor module.
            return allowType[((NABFlow)flow).getType()];
        }
        
        return true;
    }

    /**
     * Generates the text about the entry to be displayed to the user. 
     * Should be short.
     * @return short description of the module specific parameters.
     */
    public String getSpecificSummary() {
        boolean added = false;
        summary.delete(0, summary.length());
        for (int i = 0; i < allowType.length; i++) {
            if(allowType[i]){
                if(added) {
                    summary.append(" ");
                }
                summary.append(NABFlow.typeNames[i]);
                added = true;
            } else {
                added = false;
            }
        }
        return summary.toString();
    }

    /**
     * This value must be the same as that returned by the Descriptor.moduleName() 
     * method. This is used to determined which editor to use.
     * @return The name of the module that generated this flow entry.
     */
    public String getModuleName() {
        return "NABFlow";
    }

    /**
     * This method is called by the super class to construct a complete serialized
     * stream of the entry.
     * @return Message that contains enough enformation to reconstruct the specific
     * data.
     */
    protected Message getSpecific() {
        NABFlowSpecificMessage nsm = new NABFlowSpecificMessage();
        nsm.setAllow(allowType);
        
        return nsm;
    }
}